#include <iostream>#include "DoublyLinkedList.hpp"#include "LinkedListFunctions.hpp"using namespace std;/* * A C++ program that solves the Erathosthenes problem. * - Jun Yeop Na (2016-11-14) * * We use a doubly linked list to make a Erathosthenes table; * We make a doubly linked list containing values 1(start) - N(end) * Then we simulate the Erathosthenes method by deleting the node * containing the erased value from the chain of doubly linked nodes * we keep count of the number of composite numbers erased in a variable * and when the counting number equals the given k, we print out the value * that was most recently erased. */int main(){    int N, k;        /*     * Receive the inputs.     */         cin >> N;    cin >> k;            /*     * Define a table of numbers including values 2 ~ N using     * N - 1 doubly linked lists.     * the nodes are connected by increasing order of the value that they contain.     */         DoublyLinkedList *head = new DoublyLinkedList(2);    DoublyLinkedList *tail = head;    DoublyLinkedList *temp;        for(int i = 2; i <= N; i++)    {        /*         * make nodes containing value i(2 <= i <= n),         * store it to the temp node, and then connect the temp node         * to the tail of the linked lists, since it contains the         * largest value in the current iteration.         */                  temp = new DoublyLinkedList(i);                  temp->set_prev(tail);         tail->set_next(temp);                  /*          * temp is now the new tail, so           * update end          */                  tail = temp;    }            /*     * Now the N - 1 nodes containing values     * 2 ~ N are linked together in increasing order of their value.     * We now simulate the Erathosthene's algorithm of finding     * prime numbers to find out the kth deleted number.     */          int prime_number;     int erase_cnt = 0;          /*      * We store the number that is becoming the axis of the deleting      * process in prime_number.      */          DoublyLinkedList *temp_head = head;          int kth_erased_number;                    while(head != NULL && erase_cnt < k)     {        prime_number = head->get_value();        temp = head->get_next();                /*        * We picked the head node as the first prime number,        * so we need to remove the current head node        * and make the next node the new head.        */         head = head->get_next();        disconnect(temp_head);                while(temp != NULL)        {            if(temp->get_value() % prime_number == 0)            {                /*                 * Numbers that are divisible by the current prime number.                 * we erase this node from the table and then raise the value                 * of erase_cnt by 1.                 */                                  erase_cnt++;                                  if(erase_cnt == k)                 {                     kth_erased_number = temp->get_value();                                          disconnect(temp);                     break;                 }                                  disconnect(temp);            }        }              }          /*      * The while loop ends in one of the two reasons      * 1) We found the kth erased number      * 2) k is too big; We erased all the composite numbers      *    up to N but still error_cnt hasn't reached k      */          if(erase_cnt == k)     {         /*          * Case 1. We print the kth erased number          */                    cout << kth_erased_number << endl;     }     else     {         /*          * Case 2. We print an error message saying that k is too big          */                    cout << "k is too big; There is no number that is erased at the kth step";     }          return 0;}
